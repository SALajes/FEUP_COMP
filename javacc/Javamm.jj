/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Javamm.jj */
/*@egen*/options {
	LOOKAHEAD = 1;
	STATIC = false;
	             
}

PARSER_BEGIN(Javamm)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Javamm/*@bgen(jjtree)*/implements JavammTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTJavammState jjtree = new JJTJavammState();

/*@egen*/
    static int numErrors = 0;
    static final int MAX_NUM_ERRORS = 16;
	public static void main(String args[]) throws RuntimeException {
		try{
		    Javamm.numErrors = 0;
		    Javamm javamm = new Javamm(new java.io.FileInputStream(args[0]));
		    SimpleNode root = javamm.Start();

		    if (Javamm.numErrors > 0) {
                System.out.println("Errors ocurred");
                throw new RuntimeException();
            }

            root.dump("");

		} catch(FileNotFoundException e){
		    System.out.println("File not found");
		    System.exit(-1);
		}catch(ParseException e) { throw new RuntimeException(); }
	}
}

PARSER_END(Javamm)

SKIP: {
	" " | "\r" | "\t" | "\n"
	| < "//"(~["\n","\r"])*("\n" | "\r" | "\r\n")>
	| < "/*"(~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN: {
  < IMPORT: "import" >
| < CLASS: "class" >
| < EXTENDS: "extends" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < NEW: "new" >
| < LEN: "length" >
| < MAIN: "main" >
| < STRING: "String" >
| < INT: "int" >
| < BOOLEAN: "boolean" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < TRUE: "true" >
| < FALSE: "false" >
| < THIS: "this" >
| < LTHAN: "<" >
| < GTHAN: ">" >
| < PLUS: "+" >
| < MINUS: "-" >
| < ASTERISK: "*" >
| < FSLASH: "/" >
| < EQUALS: "=" >
| < DEQUALS: "==" >
| < AND: "&&" >
| < SEMICOL: ";" >
| < COL: "," >
| < DOT: "." >
| < NOT: "!" >
| < OCURLY: "{" >
| < CCURLY: "}" >
| < OPAREN: "(" >
| < CPAREN: ")" >
| < OSBRACKET: "[" >
| < CSBRACKET: "]" >
| < RETURN: "return" >
| < NUM: ((["0"-"9"])+) >
| < ID: (["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a"-"z", "_", "$"])*) >
}

SimpleNode Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) Start */
        try {
/*@egen*/
	( ImportDeclaration() )*
	ClassDeclaration() <EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ImportDeclaration()         : {/*@bgen(jjtree) Import */
                                     ASTImport jjtn000 = new ASTImport(JJTIMPORT);
                                     boolean jjtc000 = true;
                                     jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Import */
        try {
/*@egen*/
	<IMPORT>  [<STATIC> ]
	id=<ID> {jjtn000.ident=id.image;} [ ImportDeclarationDot() ]
	[Type()]
	<SEMICOL>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ImportDeclarationDot()       : { Token id; } {/*@bgen(jjtree) Import */
    {
      ASTImport jjtn001 = new ASTImport(JJTIMPORT);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (<DOT> id=<ID> {jjtn001.ident = id.image;}  ImportDeclarationDot())/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
      }
    }
/*@egen*/        
    |
    <OPAREN> [ Type() (<COL> Type())* ] <CPAREN>
}

void ClassDeclaration()        : {/*@bgen(jjtree) Class */
                                   ASTClass jjtn000 = new ASTClass(JJTCLASS);
                                   boolean jjtc000 = true;
                                   jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Class */
        try {
/*@egen*/
	<CLASS> id=<ID> {jjtn000.ident=id.image;} ClassDeclarationExtends() <OCURLY>
		( VarDeclaration() )*
		( MethodDeclaration() )*
	<CCURLY>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClassDeclarationExtends()          : {/*@bgen(jjtree) Extends */
                                            ASTExtends jjtn000 = new ASTExtends(JJTEXTENDS);
                                            boolean jjtc000 = true;
                                            jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Extends */
    try {
/*@egen*/
    ( <EXTENDS> id=<ID> {jjtn000.ident=id.image;} )?/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration()      : {/*@bgen(jjtree) Var */
                               ASTVar jjtn000 = new ASTVar(JJTVAR);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Var */
        try {
/*@egen*/
	Type() id=<ID> {jjtn000.ident=id.image;} [ <EQUALS> <OCURLY> (<NUM>|<ID>) (<COL> (<NUM>|<ID>))* <CCURLY> ]<SEMICOL>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/ //curly solve
}

void MethodDeclaration()       : { } {
	<PUBLIC> ( MainDeclaration() | FunctionDeclaration())
}

void MainDeclaration()       : {/*@bgen(jjtree) Main */
                                 ASTMain jjtn000 = new ASTMain(JJTMAIN);
                                 boolean jjtc000 = true;
                                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Main */
        try {
/*@egen*/
	<STATIC> <VOID> <MAIN> <OPAREN> <STRING> <OSBRACKET> <CSBRACKET> id=<ID> {jjtn000.ident=id.image;} <CPAREN> <OCURLY>
		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() ) *
	<CCURLY>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FunctionDeclaration()         : {/*@bgen(jjtree) Method */
                                       ASTMethod jjtn000 = new ASTMethod(JJTMETHOD);
                                       boolean jjtc000 = true;
                                       jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Method */
        try {
/*@egen*/
	Type() id=<ID> {jjtn000.ident=id.image;} <OPAREN> ArgList() <CPAREN> <OCURLY>
		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() )*
		<RETURN> Expression() <SEMICOL>
	<CCURLY>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Arg()      : {/*@bgen(jjtree) Arg */
                    ASTArg jjtn000 = new ASTArg(JJTARG);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token id; } {/*@bgen(jjtree) Arg */
    try {
/*@egen*/
    Type() id=<ID>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {jjtn000.ident=id.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArgList()             : {/*@bgen(jjtree) MethodArgs */
  ASTMethodArgs jjtn000 = new ASTMethodArgs(JJTMETHODARGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ } {/*@bgen(jjtree) MethodArgs */
    try {
/*@egen*/
    [ Arg() (<COL> Arg())* ]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type()       : { } {
	(<INT> [<OSBRACKET> <CSBRACKET>])
	|
	<BOOLEAN>
	|
	<ID>
	|
	<VOID>
}

void Statement()       : { } {
	(<OCURLY> (Statement())* <CCURLY>)
	|/*@bgen(jjtree) If */
        {
          ASTIf jjtn001 = new ASTIf(JJTIF);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*/
	(<IF> <OPAREN> Expression()  (ExpressionsConnector())* <CPAREN> Statement() [<ELSE> Statement()])/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
          }
        }
/*@egen*/    //before forced an else
	|
	[LOOKAHEAD(2) <ID> StatementId()] Expression()  (ExpressionsConnector())* <SEMICOL>
	|
	<WHILE> <OPAREN>/*@bgen(jjtree) While */
        {
          ASTWhile jjtn002 = new ASTWhile(JJTWHILE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
	try {
	    //		while (i +) {
	    (Expression()  (ExpressionsConnector())* <CPAREN>) // We only need to check for errors inside the while parenthesis
	} catch(ParseException e) {
        System.out.println(e.toString());  // print the error message
        Token t;
        Javamm.numErrors++; // Increase the number of errors since execution

        if (Javamm.numErrors > Javamm.MAX_NUM_ERRORS) { // Chose 5 but this value should be passed through command line maybe?
            System.out.println("Too many errors. Aborting. (" + Javamm.numErrors + ")");
            throw e;
        }

        while(true) {
          t = getToken(1); // Skip the tokens until the close of parenthesis
          if(t.kind == CPAREN || t.kind == CCURLY){
            t = getNextToken();
            t=getToken(1);
            if(t.kind != CPAREN)
                break;
          }
          else if(t.kind == OCURLY)
            break;
          else t = getNextToken();
        }
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte002) {
          if (jjtc002) {
            jjtree.clearNodeScope(jjtn002);
            jjtc002 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte002 instanceof RuntimeException) {
            throw (RuntimeException)jjte002;
          }
          if (jjte002 instanceof ParseException) {
            throw (ParseException)jjte002;
          }
          throw (Error)jjte002;
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/        
	Statement()
}

void StatementId()       : { } {
	<EQUALS>
	|
	(<OSBRACKET> Expression() <CSBRACKET> <EQUALS>)
}

void Expression()       : { } {
	[<MINUS>] ExpressionTerminal() ( LOOKAHEAD(2) ExpressionL())?
 }

 void ExpressionL()       : { } {
 	ExpressionsConnector()
 	|
 	(<OSBRACKET> Expression() <CSBRACKET>)
 	|
 	ExpressionDot()
 }

 void ExpressionDot()       : { } {
 	<DOT> ExpressionDotL()
 }

 void ExpressionDotL()       : { } {
 	<LEN>
 	|
 	(<ID> [<OPAREN> [(Expression() (ExpressionsConnector())*) (<COL> (Expression() (ExpressionsConnector())*))*] <CPAREN>])
 }

 void ExpressionTerminal()       : { Token id;} {
 	id=<NUM>/*@bgen(jjtree) Int */
                 {
                   ASTInt jjtn001 = new ASTInt(JJTINT);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*//*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtc001 = false;
                 }
/*@egen*/ {jjtn001.ident=id.image;}/*@bgen(jjtree)*/
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001, true);
                   }
                 }
/*@egen*/     
 	|/*@bgen(jjtree) True */
        {
          ASTTrue jjtn002 = new ASTTrue(JJTTRUE);
          boolean jjtc002 = true;
          jjtree.openNodeScope(jjtn002);
        }
        try {
/*@egen*/
 	<TRUE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc002) {
            jjtree.closeNodeScope(jjtn002, true);
          }
        }
/*@egen*/      
 	|/*@bgen(jjtree) False */
        {
          ASTFalse jjtn003 = new ASTFalse(JJTFALSE);
          boolean jjtc003 = true;
          jjtree.openNodeScope(jjtn003);
        }
        try {
/*@egen*/
 	<FALSE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc003) {
            jjtree.closeNodeScope(jjtn003, true);
          }
        }
/*@egen*/       
 	|
 	<ID> [ <OPAREN> [Type() (<COL> Type())*] <CPAREN>] // a = Cenas(a,b); solve
 	|/*@bgen(jjtree) This */
        {
          ASTThis jjtn004 = new ASTThis(JJTTHIS);
          boolean jjtc004 = true;
          jjtree.openNodeScope(jjtn004);
        }
        try {
/*@egen*/
 	<THIS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc004) {
            jjtree.closeNodeScope(jjtn004, true);
          }
        }
/*@egen*/      
 	|
 	<NOT>/*@bgen(jjtree) Not */
              {
                ASTNot jjtn005 = new ASTNot(JJTNOT);
                boolean jjtc005 = true;
                jjtree.openNodeScope(jjtn005);
              }
              try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
              } catch (Throwable jjte005) {
                if (jjtc005) {
                  jjtree.clearNodeScope(jjtn005);
                  jjtc005 = false;
                } else {
                  jjtree.popNode();
                }
                if (jjte005 instanceof RuntimeException) {
                  throw (RuntimeException)jjte005;
                }
                if (jjte005 instanceof ParseException) {
                  throw (ParseException)jjte005;
                }
                throw (Error)jjte005;
              } finally {
                if (jjtc005) {
                  jjtree.closeNodeScope(jjtn005, true);
                }
              }
/*@egen*/     
 	|
 	ExpressionNew()
 	|
 	(<OPAREN> Expression() (ExpressionsConnector())* <CPAREN>)
 }

 void ExpressionNew()       : { } {
 	<NEW> ExpressionNewL()
 }

void ExpressionNewL()       : { } {
	(<INT> <OSBRACKET> Expression() <CSBRACKET>)
	|
	(<ID> <OPAREN> <CPAREN>)
}

void ExpressionsConnector()       : { } {
    [(<DEQUALS> | <AND> | <LTHAN> | <GTHAN> | <PLUS> | <MINUS> | <ASTERISK> | <FSLASH>)] Expression() //== solve, not the best bc i cant have ex: a = b == c
}