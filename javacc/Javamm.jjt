options {
	LOOKAHEAD = 1;
	STATIC = false;
	MULTI = true;
}

PARSER_BEGIN(Javamm)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Javamm {
    static int numErrors = 0;
    static final int MAX_NUM_ERRORS = 16;
	public static void main(String args[]) throws RuntimeException {
		try{
		    Javamm.numErrors = 0;
		    Javamm javamm = new Javamm(new java.io.FileInputStream(args[0]));
		    SimpleNode root = javamm.Start();

		    if (Javamm.numErrors > 0) {
                System.out.println("Errors ocurred");
                throw new RuntimeException();
            }

            root.dump("");
		    //build symbol table
		    //check semantics
		    //display symbol table

		} catch(FileNotFoundException e){
		    System.out.println("File not found");
		    System.exit(-1);
		}catch(ParseException e) { throw new RuntimeException(); }
	}

	public static void whileErrorRecovery(ParseException e){
	        System.out.println(e.toString());  // print the error message
            Token t;
            Javamm.numErrors++; // Increase the number of errors since execution

            if (Javamm.numErrors > Javamm.MAX_NUM_ERRORS) {
                System.out.println("Too many errors. Aborting. (" + Javamm.numErrors + ")");
                throw e;
            }

            while(true) {
              t = getToken(1); // Skip the tokens until the close of parenthesis
              if(t.kind == CPAREN || t.kind == CCURLY){
                t = getNextToken();
                t=getToken(1);
                if(t.kind != CPAREN)
                    break;
              }
              else if(t.kind == OCURLY)
                break;
              else t = getNextToken();
            }
	}
}

PARSER_END(Javamm)

SKIP: {
	" " | "\r" | "\t" | "\n"
	| < "//"(~["\n","\r"])*("\n" | "\r" | "\r\n")>
	| < "/*"(~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN: {
  < IMPORT: "import" >
| < CLASS: "class" >
| < EXTENDS: "extends" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < NEW: "new" >
| < LEN: "length" >
| < MAIN: "main" >
| < STRING: "String" >
| < INT: "int" >
| < BOOLEAN: "boolean" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < TRUE: "true" >
| < FALSE: "false" >
| < THIS: "this" >
| < LTHAN: "<" >
| < GTHAN: ">" >
| < PLUS: "+" >
| < MINUS: "-" >
| < ASTERISK: "*" >
| < FSLASH: "/" >
| < EQUALS: "=" >
| < DEQUALS: "==" >
| < AND: "&&" >
| < SEMICOL: ";" >
| < COL: "," >
| < DOT: "." >
| < NOT: "!" >
| < OCURLY: "{" >
| < CCURLY: "}" >
| < OPAREN: "(" >
| < CPAREN: ")" >
| < OSBRACKET: "[" >
| < CSBRACKET: "]" >
| < RETURN: "return" >
| < NUM: ((["0"-"9"])+) >
| < ID: (["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a"-"z", "_", "$"])*) >
}

SimpleNode Start() : { } {
	( ImportDeclaration() )*
	ClassDeclaration() <EOF> 
	{ return jjtThis; }
}

void ImportDeclaration() #Import : { Token id; } {
	<IMPORT>  [<STATIC> ]
	id=<ID> { jjtThis.identity=id.image; } [ ImportDeclarationDot() ]
	[Type()]
	<SEMICOL>
}

void ImportDeclarationDot() #void : { Token id; } {
    (<DOT> id=<ID> { jjtThis.identity = id.image; }  ImportDeclarationDot())
    |
    <OPAREN> [ Type() (<COL> Type())* ] <CPAREN>
}

void ClassDeclaration() #Class : { Token class_id, extend_class; } {
	<CLASS> class_id=<ID> { jjtThis.identity=class_id.image; }
	  ( <EXTENDS> extend_class=<ID> { jjtThis.extend=extend_class.image; } )? <OCURLY>
		( VarDeclaration() )*
		( MethodDeclaration() )*
	<CCURLY>
}

void MethodDeclaration() #void : { } {
	<PUBLIC> ( MainDeclaration() | FunctionDeclaration())
}


void MainDeclaration() #Main : { Token id; } {
	<STATIC> <VOID> <MAIN> <OPAREN> <STRING> <OSBRACKET> <CSBRACKET> id=<ID> { jjtThis.identity=id.image; } <CPAREN> <OCURLY>
		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() ) *
	<CCURLY>
}

void VarDeclaration() #Var : { String type; Token id; } {
	type=Type() id=<ID> { jjThis.type=type; jjtThis.identity=id.image; }
	    [ <EQUALS> <OCURLY> (<NUM>|<ID>) (<COL> (<NUM>|<ID>))* <CCURLY> ]<SEMICOL> //curly solve
}

void FunctionDeclaration() #Method : { String type; Token id; } {
	type=Type() id=<ID> { jjtThis.identity=id.image; jjtThis.type=type; } <OPAREN>
	    FunctionArguments() <CPAREN> <OCURLY>

		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() )*
		<RETURN> Expression() <SEMICOL>
	<CCURLY>
}

void Argument() : { String type; Token id; } {
    type=Type() id=<ID> { jjtThis.type=type; jjtThis.identity=id.image; }
}

void FunctionArguments() #Arguments : { } {
    [ Argument() (<COL> Argument())* ]
}

String Type() #void : { String return_value; Token id; } {
	<INT> { return_value = "int"; }
	[<OSBRACKET> <CSBRACKET> { return_value = "int[]"; }]
	|
	<BOOLEAN> { return_value = "boolean"; }
	|
	id=<ID> { return_value = id.image; }
	|
	<VOID> { return_value = "void"; }

	{ return return_value; }
}

void Statement() #void : {} {
	(<OCURLY> (Statement())* <CCURLY>)
	|
	IfStatement()
	|
    WhileStatement()
	|
	( LOOKAHEAD(2)
    VariableInit()
    |
    ArrayInit()
	|
	Expression()
	)
}

void IfStatement() #IF : {} {
    <IF> <OPAREN> Expression() #CONDITION <CPAREN>
            Statement() #THEN
    [<ELSE>
        Statement() #ELSE
    ]
}

void WhileStatement() #WHILE : {} {
    <WHILE> <OPAREN>
    	try {
    	    (Expression())* <CPAREN> // We only need to check for errors inside the while parenthesis
    	} catch(ParseException e) {
            Javamm.whileErrorRecovery(e);
    	}
        Statement()
}

void VariableInit() : { Token id; } {
    id=<ID> { jjtThis.identity=id; }
        <EQUALS> Expression() <SEMICOL>
}

void ArrayInit() : { Token id; } {
    id=<ID> { jjtThis.identity=id; }
        <OSBRACKET> Expression() <CSBRACKET> <EQUALS> Expression() <SEMICOL>
}

void Expression() #void : { } {
    //We will now dispose operators from lowest to highest precedence:
    // &&, <, + -, * /, new, !, (), ., []
    LessThan() (<AND> LessThan())*
 }

void LessThan() : {} {
    AdditionSubtraction() (<LTHAN> AdditionSubtraction())*
}

void AdditionSubtraction() : {Token operator;} {
    MultiplicationDivision()
    (
        (operator=<PLUS> | operator=<MINUS>) MultiplicationDivision() { jjtThis.identity=operator.image; }
    )*
}

void MultiplicationDivision() : { Token operator; } {
    ExpressionIntermediateDivision()
    (
        (operator=<ASTERISK> | operator=<FSLASH> ) ExpressionTerminal() { jjtThis.identity=operator.image; }
    )*
}

void ExpressionIntermediateDivision() : {} {
    <NOT> Expression() #Not
    |
    ExpressionTerminal() [<DOT> ExpressionDot()]
}

void ExpressionTerminal() #void : { Token id;} {
    id=<NUM> {jjtThis.identity=Integer.parseInt(id.image);} #Integer
    |
    id=<TRUE> {jjtThis.identity=id.image;} #True
    |
    id=<FALSE> {jjtThis.identity=id.image;} #False
    |
    <THIS> #This //faz sentido guardar isto num token?
    |
    id=<ID> {jjtThis.identity=id.image;} #ID
    |
    <OPAREN> Expression() <CPAREN>
    |
    ExpressionNew()
}

void ExpressionDot() #void : { } {
    <LEN>
    |
    (ExpressionTerminal() <DOT>)* <ID> <OPAREN> [Expression() (<COL> Expression())*] <CPAREN>
}


void ExpressionNew() #void : { Token return_value; } {
    <NEW>
    (
        <INT> <OSBRACKET> Expression() <CSBRACKET> { jjThis.returns="int[]"; }
        |
        return_value=<ID> { jjtThis.returns=return_value.image; }  <OPAREN> <CPAREN>
    )
}