options {
	LOOKAHEAD = 1;
	STATIC = false;
	MULTI = true;
}

PARSER_BEGIN(Javamm)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Javamm {
    static int numErrors = 0;
    static final int MAX_NUM_ERRORS = 16;
	public static void main(String args[]) throws RuntimeException {
		try{
		    Javamm javamm = new Javamm(new java.io.FileInputStream(args[0]));
		    SimpleNode root = javamm.Start();
            root.dump("");
            if (javamm.numErrors > 0) {
                System.out.println("Errors ocurred");
                throw new RuntimeException();
            }
		} catch(FileNotFoundException e){
		    System.out.println("File not found");
		    System.exit(-1);
		}catch(ParseException e) { throw new RuntimeException(); }
	}
}

PARSER_END(Javamm)

SKIP: {
	" " | "\r" | "\t" | "\n"
	| < "//"(~["\n","\r"])*("\n" | "\r" | "\r\n")>
	| < "/*"(~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN: {
  < IMPORT: "import" >
| < CLASS: "class" >
| < EXTENDS: "extends" >
| < PUBLIC: "public" >
| < STATIC: "static" >
| < VOID: "void" >
| < NEW: "new" >
| < LEN: "length" >
| < MAIN: "main" >
| < STRING: "String" >
| < INT: "int" >
| < BOOLEAN: "boolean" >
| < IF: "if" >
| < THEN: "then" >
| < ELSE: "else" >
| < WHILE: "while" >
| < TRUE: "true" >
| < FALSE: "false" >
| < THIS: "this" >
| < LTHAN: "<" >
| < GTHAN: ">" >
| < PLUS: "+" >
| < MINUS: "-" >
| < ASTERISK: "*" >
| < FSLASH: "/" >
| < EQUALS: "=" >
| < DEQUALS: "==" >
| < AND: "&&" >
| < SEMICOL: ";" >
| < COL: "," >
| < DOT: "." >
| < NOT: "!" >
| < OCURLY: "{" >
| < CCURLY: "}" >
| < OPAREN: "(" >
| < CPAREN: ")" >
| < OSBRACKET: "[" >
| < CSBRACKET: "]" >
| < RETURN: "return" >
| < NUM: ((["0"-"9"])+) >
| < ID: (["A"-"Z", "a"-"z", "_", "$"](["0"-"9", "A"-"Z", "a"-"z", "_", "$"])*) >
}

SimpleNode Start(): { } { 
	( ImportDeclaration() )*
	ClassDeclaration() <EOF> 
	{ return jjtThis; }
}

void ImportDeclaration() : { } {
	<IMPORT> [<STATIC>]
	<ID> [(<DOT> <ID> )* <OPAREN> [Type() (<COL> Type())*] <CPAREN>]
	[Type()]
	<SEMICOL>
}

void ClassDeclaration() : { } {
	<CLASS> <ID> [ <EXTENDS> <ID> ] <OCURLY>
		( VarDeclaration() )*
		( MethodDeclaration() )*
	<CCURLY>
}

void VarDeclaration()  : { } {
	Type() <ID> [ <EQUALS> <OCURLY> (<NUM>|<ID>) (<COL> (<NUM>|<ID>))* <CCURLY> ]<SEMICOL> //curly solve
}

void MethodDeclaration()  : { } {
	<PUBLIC> ( MainDeclaration() | FunctionDeclaration())
}

void MainDeclaration()  : { } {
	<STATIC> <VOID> <MAIN> <OPAREN> <STRING> <OSBRACKET> <CSBRACKET> <ID> <CPAREN> <OCURLY>
		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() ) *
	<CCURLY>
}

void FunctionDeclaration()  : { } {
	Type() <ID> <OPAREN> [ Type() <ID> (<COL> Type() <ID> )* ] <CPAREN> <OCURLY>
		( LOOKAHEAD(2) VarDeclaration() )*
		( Statement() )*
		<RETURN> Expression() <SEMICOL>
	<CCURLY>
}

void Type()  : { } {
	(<INT> [<OSBRACKET> <CSBRACKET>])
	|
	<BOOLEAN>
	|
	<ID>
	|
	<VOID>
}

void Statement()  : { } {
	(<OCURLY> (Statement())* <CCURLY>)
	|
	(<IF> <OPAREN> Expression()  (ExpressionsConnector())* <CPAREN> Statement() [<ELSE> Statement()])//before forced an else
	|
	[LOOKAHEAD(2) <ID> StatementId()] Expression()  (ExpressionsConnector())* <SEMICOL>
	|
	<WHILE> <OPAREN>
	try {
	    (Expression()  (ExpressionsConnector())* <CPAREN>) // We only need to check for errors inside the while parenthesis
	} catch(ParseException e) {
        System.out.println(e.toString());  // print the error message
        Token t;
        Javamm.numErrors++; // Increase the number of errors since execution

        if (Javamm.numErrors > Javamm.MAX_NUM_ERRORS) { // Chose 5 but this value should be passed through command line maybe?
            System.out.println("Too many errors. Aborting.");
            throw e;
        }

        do {
          t = getNextToken(); // Skip the tokens until the close of parenthesis
        } while (!(t.kind == CPAREN || t.kind == OCURLY || t.kind == CCURLY || t.kind == SEMICOL));
	}
	Statement()
}

void StatementId()  : { } {
	<EQUALS>
	|
	(<OSBRACKET> Expression() <CSBRACKET> <EQUALS>)
}

void Expression()  : { } {
	[<MINUS>] ExpressionTerminal() ( LOOKAHEAD(2) ExpressionL())?
 }

 void ExpressionL()  : { } {
 	ExpressionsConnector()
 	|
 	(<OSBRACKET> Expression() <CSBRACKET>)
 	|
 	ExpressionDot()
 }

 void ExpressionDot()  : { } {
 	<DOT> ExpressionDotL()
 }

 void ExpressionDotL()  : { } {
 	<LEN>
 	|
 	(<ID> [<OPAREN> [(Expression() (ExpressionsConnector())*) (<COL> (Expression() (ExpressionsConnector())*))*] <CPAREN>])
 }

 void ExpressionTerminal()  : { } {
 	<NUM> #Integer
 	|
 	<TRUE> #True
 	|
 	<FALSE> #False
 	|
 	<ID> [ <OPAREN> [Type() (<COL> Type())*] <CPAREN>] // a = Cenas(a,b); solve
 	|
 	<THIS> #This
 	|
 	<NOT> Expression() #Negation
 	|
 	ExpressionNew()
 	|
 	(<OPAREN> Expression() (ExpressionsConnector())* <CPAREN>)
 }

 void ExpressionNew()  : { } {
 	<NEW> ExpressionNewL() #New
 }

void ExpressionNewL()  : { } {
	(<INT> <OSBRACKET> Expression() <CSBRACKET>)
	|
	(<ID> <OPAREN> <CPAREN>)
}

void ExpressionsConnector() : { } {
 [(<DEQUALS> | <AND> | <LTHAN> | <GTHAN> | <PLUS> | <MINUS> | <ASTERISK> | <FSLASH>)] Expression() #Connector//== solve, not the best bc i cant have ex: a = b == c
}